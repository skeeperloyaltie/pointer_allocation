#include <stdio.h>#include <stdlib.h>#include <sys/mman.h>#include <sys/types.h>#include <sys/stat.h>#include <fcntl.h>#include <unistd.h>int nloop = 50;int false = 0;int true = 1;/**********************************************************\ * Function: increment a counter by some amount one by one * * argument: ptr (address of the counter), increment       * * output  : nothing                                       * **********************************************************/void add_n(int *ptr, int increment){    int i,j;    for (i=0; i < increment; i++){        *ptr = *ptr + 1;        for (j=0; j < 1000000;j++);    }}int main(){    int pid;        /* Process ID                     */    int *countptr;  /* pointer to the counter         */    int *flag;    int *turn;    int fd;     /* file descriptor to the file "containing" my counter */    int f_flag;    int f_turn;    int zero = 0; /* a dummy variable containing 0 */    system("rm -f counter");    system("rm -f flag");    system("rm -f turn");    /* create a file which will "contain" my shared variable */    fd = open("counter",O_RDWR | O_CREAT);    f_flag = open("flag", O_RDWR | O_CREAT);    f_turn = open("turn", O_RDWR | O_CREAT);    write(fd,&zero,sizeof(int));    write(f_flag,"",sizeof(int) * 2);    write(f_turn,"",sizeof(int));    /* map my file to memory */    countptr = (int *) mmap(NULL, sizeof(int),PROT_READ | PROT_WRITE, MAP_SHARED, fd,0);    flag = (int *) mmap(NULL, sizeof(int) * 2,PROT_READ | PROT_WRITE, MAP_SHARED, f_flag,0);    turn = (int *) mmap(NULL, sizeof(int),PROT_READ | PROT_WRITE, MAP_SHARED, f_turn,0);    if (!countptr) {        printf("Mapping failed\n");        exit(1);    }    *countptr = 0;    flag[0] = 0;    flag[1] = 0;    *turn = 0;    close(fd);    close(f_flag);    close(f_turn);    setbuf(stdout,NULL);    pid = fork();    if (pid < 0){        printf("Unable to fork a process\n");        exit(1);    }    if (pid == 0) {        /* The child increments the counter by two's */        while (*countptr < nloop){            flag[0] = true;            *turn = 1;            while (flag[1] == true && *turn == 1){            }            if (*countptr < nloop){                add_n(countptr,2);                printf("Child process -->> counter= %d\n",*countptr);            }            flag[0] = false;        }        close(fd);    }    else {        /* The parent increments the counter by twenty's */        while (*countptr < nloop){            flag[1] = true;            *turn = 0;            while (flag[0] == true && *turn == 0){            }            if (*countptr < nloop){                add_n(countptr,20);                printf("Parent process -->> counter = %d\n",*countptr);            }            flag[1]= false;        }        close(fd);        close(f_flag);        close(f_turn);    }}